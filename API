class lexer{
  bool addTokenDef(tokenDef , ID);
  vector<TokenDef> tds;
  void init();
  unique_ptr map;
}

class TokenDef {
  TokenDef(str, ID);	////str can be "a string" or "[a-z]" or "[^b-f]"
  operaotr||(tokenDef);
  operaotr>>(tokenDef);
  operaotr*();//0 or more
  operaotr+();//1 or more
  operaotr-();//0 or 1
}

map:
state0[0-127] means start, never other state goes back to it
state1, ..., stateN, N means the probable max length of str
state[0] means without reading a char the state can move itself
|| causes other state shift on original state
>> causes another state shift on final state
+-* causes final state shift back to original state

but, note! *+- needs its own map rows, which not be shared, to avoid mixing between them
for example, (abc)* and (cba)* if share the same 3 rows, then, will cbaabc or abccba be recognized?

state  a-zA-Z 0-9 _ ,.+-/*  \t\n... " '  ,  ;
0	1     2   1   4    0	   7  8  6  6	
1 //id  1	1 1   0	    0	   0  0
2 //num 0    2    0   0	    0 	   0  0
3 //str 0.....................................
4 //op  0     0   0   4    0	   0
5 //str 0.....................................
6 //pun 0............
7 //tem 7............		   3  7
8 //tem 8............                 0

function parse(rule r)
  offset start = 0;	offset end = se.size();
  Production pd = r.transform(r.parse(start, end, se));
  
r.parse(offset& start, const offset, const std::vector<Token>&)
  offset cs = start;
  pds = r.expr(start, end, se);
  if(start == cs) return false
  Production pd = transform(pds);

  typedef function<bool(start, end, vector<token>)> eval;
  
  eval _LinkRule::compile( out_eval ){
    for(i = size-1; i >0; --i)
	r.compile(out_eval);
      out_eval = [](){	
	if(r.eval(start, end, npd))
	  pd->result.push_back(npd);
	  return true;
	return false;
      }
    r = at(0);
    r.compile(out_eval);
    out_eval = [](){	
	pd->result = new vector();
	if(r.eval(start, end, npd))
	if(out_eval(start, end, pd))
	  pd->result.push_back(npd);
	  return true;
	return false;
    }
    return out_eval;
  }
  
  eval _KneeRule::compile( out_eval ){
    eval ev = [](){
    if(pd->result == null)
      pd->result = new vector;
    if(r.eval(start, end, npd){
      if(ev(start, end, pd)){
	pd->result.push_back(npd);
	return true;
      }
      reset start; 
    }
    if(out_eval(start, end, null))
      return true;
    };
    return ev;
  }
  
  eval _OptionRule::compile( out_eval )
  {
    eval ev =  [](){
      if(r1.eval(start, end, pd) && out_eval(start, end, null) ) return true;
      if(r2.eval(start, end, pd)) return true;
      return false;
    };
    return ev;
  }
  
  *eval(start, end, pd):	//out_eval is ref outside of fun
    if(pd->result == null)
      pd->result = new vector;
    eval ev = [](){
      if(eval(start, end, pd) && out_eval(null)) return true;
    }
    if(r.eval(start, end, npd){
      if(ev(start, end, pd)){
	pd->result.push_back(npd);
	return true;
      }
    }
    else
    reset start; 
    if(out_eval(start, end, null))
      return true;
    
  >>eval(start, end, pd):	//out eval?
    if(pd->result == null)	pd->result = new vector();
    if(r.eval(start, end, npd))
      if(out_eval(start, end, pd))
	pd->result.push_back(npd);
	return true;
    return false;

=====================================================
why we need a _rule_wrapper, instead of using shared_ptr of _rule directly?

1 shared_ptr can be recognized as a ptr, simply
2 when constructing rules, such as constructing a _LinkRule, we need a copy of , kind of, a ptr to help compile
3 if we copy ptr(shared_ptr is the same) of _rule, the comes the question that:
we cannot change the def content of copyed _rule in the later assignment, even the type info, because assignment just changes ptr, not content of ptr
here is the bad example:
  rule names; rule start = names >> names; names = rule(ID);
when constructing rule start, it has copied ptr of names, assignment operaotr later doesn't work anymore
unless we make operaotr= to change def content of ptr, then type of ptr must cover all situations, and type info is ambiguous
4 so, we can add a _rule_wrapper upon ptr of _rule, and hold a ptr of _rule_wrapper inside Rule
when constructing rule, just copy ptr of _rule_wrapper, when compiling, use ptr of _rule inside struct _rule_wrapper
we overide operaotr=, not to change ptr of _rule_wrapper, because it cannot change real content of the copied one
we change ptr of _rule inside struct _rule_wrapper, so every copied ptr of _rule_wrapper is influenced
in fact, it can be put simply:
  struct A { T* n; };
  A a = b; //doesn't change the content of the original a.n
  *(a.n) = *(b.n); //now it does
  a.n->ptr = b.n->ptr; //works also
5 finally, 
  if we want to store const, just copy
  if we want to store sth to be changed, just copy ptr of it, and in operaotr=, change real content of ptr
  if we want of store (ptr of sth) to be changed, just copy ptr of (ptr of it), etc...

	
